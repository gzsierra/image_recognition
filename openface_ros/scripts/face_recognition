#!/usr/bin/env python

import cv2
import rospy
import time
from threading import Thread
import threading
from argparse import ArgumentParser, FileType
from openface_ros.face_recognizer import FaceRecognizer
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError
from std_msgs.msg import String



# Assign description to the help doc
parser = ArgumentParser(description='Get face properties using the Skybiometry API')

# Add arguments
parser.add_argument('-i', '--image', type=str, help='Image', required=False)
parser.add_argument('-t', '--topic', type=str, help='Image Topic', required=False,
                    default="/usb_cam/image_raw")
parser.add_argument('-T', '--Train', type=int, help='Train a new name', required=False,
                    default=0)
parser.add_argument('-n', '--name', type=str, help='Name', required=False)
parser.add_argument('-k', '--align_path', type=str, help='DLib Align path', required=False,
                    default="~/src/openface/models/dlib/shape_predictor_68_face_landmarks.dat")
parser.add_argument('-s', '--net_path', type=str, help='Openface neural network path', required=False,
                    default='~/src/openface/models/openface/nn4.small2.v1.t7')
parser.add_argument('-d', '--db', type=FileType('r'), help='Load already trained faces db from file')#, required=False,
#                     default="/tmp/trained.out")
# parser.add_argument('-o','--outfile', type=FileType('w'), help='Where to output the trained faces database', required=False,
#                     default="/tmp/trained.out")
parser.add_argument('-v', '--verbose', help="Increase output verbosity", action="store_true")
args = parser.parse_args()

bridge = CvBridge()
face_recognizer = FaceRecognizer(args.align_path, args.net_path)

pubImage = rospy.Publisher('/face_recognition/detection', Image, queue_size=1)

max_thread = 4
thread_id = 0
lock = False
# face = frame[y:y+h,x:x+w]

if args.db:
    face_recognizer.restore_trained_faces(args.db)

def _create_subscriber(topic_name):
    """
    Method that creates a subscriber to a sensor_msgs/Image topic
    :param topic_name: The topic_name
    """
    rospy.init_node('listener', anonymous=True)
    sub = rospy.Subscriber(topic_name, Image, callback)
    rospy.loginfo("Listening to %s -- spinning .." % sub.name)
    rospy.spin()

def callback(msg):
    """
    Method that will get a image from a topic
    :param topic: The msg from subscriber listenning on ex: `/usb_cam/image_raw`
    """
    # print("Enter callback")
    try:
        cv_image = bridge.imgmsg_to_cv2(msg, "bgr8")
        # train(cv_image)
        recognize(cv_image)
    except CvBridgeError as e:
        rospy.logerr(e)

def recognize(cv_image):
    # Pretty print the output
    global thread_id
    global lock
    global label

    # print("Enter recognize")
    nb_face = 0
    label = ""
    unknown = ""
    try:
        while(lock):
            print("Lock is blocking MAIN loop")
            time.sleep(5)
        faces = face_recognizer.recognize(cv_image)
        if len(faces) != 0:
            for face in faces:
                roi = face.roi

                x_offset = roi.x_offset
                y_offset = roi.y_offset
                width = roi.width
                height = roi.height

                if len(face.l2_distances) != 0:
                    label = face.l2_distances[0]
                    unknown = str(label.label)[:-1]
                    print("unknown found")
                    print(unknown)

                if (thread_id < max_thread) & (unknown != "unknown"):
                    train(thread_id, cv_image[y_offset:y_offset+height,x_offset:x_offset+ width])
                    thread_id += 1


                nb_face += 1
                print "l2: %s %d: (%d, %d, %d, %d)" % (label, nb_face, x_offset, y_offset, width, height)
                cv2.rectangle(cv_image, (x_offset, y_offset), (x_offset+ width, y_offset+height), (0, 255, 0), 2)
    except Exception as e:
        print "An error occurred: %s" % e
    pubImage.publish(bridge.cv2_to_imgmsg(cv_image, "bgr8"))

def train(id, face_image):
    # Pretty print the output
    # print("Enter Training")

    if face_image is not None:
        try:
            Train(id, face_recognizer, face_image)
        except Exception as e:
            print "An error occurred: %s" % e

class Train():
    def __init__(self, id, recognizer, face):
        self.id = id
        self.recognizer = recognizer
        self.face = face
        print("Thread " + str(self.id))
        self.recognizer.train(self.face, "unknown"+str(id))

        rospy.init_node('listener', anonymous=True)
        pubLabel = rospy.Publisher('/face_recognition_'+str(self.id)+'/label', String, queue_size=1)
        pubface = rospy.Publisher('/face_recognition_'+str(self.id)+'/face', Image, queue_size=1)
        self.sub = rospy.Subscriber('/face_recognition_'+str(self.id)+'/label', String, self.setLabel)

    def setLabel(self, msg):
        global thread_id
        global lock
        lock = True
        print("SetLabel")
        print(msg.data)
        self.recognizer.train(self.face, msg.data)
        thread_id -= 1
        self.sub.unregister()
        lock = False

def shutdown():
    print("Shuting down everything ! :)")

## MAIN STARTER ##
if __name__ == '__main__':
    print("Starting Main")
    rospy.on_shutdown(shutdown)
    _create_subscriber(args.topic)
